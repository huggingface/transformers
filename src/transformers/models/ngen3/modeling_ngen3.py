#!/usr/bin/env python3
# coding=utf-8
# --------------------------------------------------------------------------------
# This file was automatically generated from the NGEN3 modular source.
# Do NOT edit this file manually as any modifications will be overwritten.
# --------------------------------------------------------------------------------
"""
NGEN3 Modeling file

This module implements an HF Transformersâ€“compatible causal LM (NGEN3),
featuring rotary positional embeddings, an optional instruct dense layer, and
support for a Mixture-of-Experts (MoE) feedforward block.

The code structure and documentation style follow the Gemma3 model conventions.
"""

import math
import torch
import torch.nn as nn
import torch.nn.functional as F
from transformers import PreTrainedModel
from transformers.models.ngen3.configuration_ngen3 import NGEN3Config
from transformers.modeling_outputs import CausalLMOutputWithCrossAttentions
from .modular_ngen3 import NGEN3  # Import the modular architecture

def apply_rotary_pos_emb(q: torch.Tensor, k: torch.Tensor) -> tuple:
    """
    Applies rotary positional embeddings (RoPE) to the query and key tensors.
    
    Args:
        q (torch.Tensor): Query of shape (B, n_head, T, head_dim)
        k (torch.Tensor): Key of shape (B, n_head, T, head_dim)
    
    Returns:
        Tuple[torch.Tensor, torch.Tensor]: The rotated query and key.
    """
    T = q.size(-2)
    dim = q.size(-1)
    device = q.device
    inv_freq = 1.0 / (10000 ** (torch.arange(0, dim, 2, device=device).float() / dim))
    positions = torch.arange(T, device=device).float()
    sinusoid_inp = torch.einsum("i,j->ij", positions, inv_freq)
    sin = torch.sin(sinusoid_inp).unsqueeze(0).unsqueeze(0)
    cos = torch.cos(sinusoid_inp).unsqueeze(0).unsqueeze(0)
    q1, q2 = q[..., :dim//2], q[..., dim//2:]
    k1, k2 = k[..., :dim//2], k[..., dim//2:]
    q_rot = torch.cat((q1 * cos - q2 * sin, q2 * cos + q1 * sin), dim=-1)
    k_rot = torch.cat((k1 * cos - k2 * sin, k2 * cos + k1 * sin), dim=-1)
    return q_rot, k_rot

class NGEN3ForCausalLM(PreTrainedModel):
    config_class = NGEN3Config
    base_model_prefix = "ngen3"

    def __init__(self, config: NGEN3Config):
        super().__init__(config)
        self.ngen3 = NGEN3(config)
        self.init_weights()

    def init_weights(self):
        for module in self.modules():
            if isinstance(module, (nn.Linear, nn.Embedding)):
                module.weight.data.normal_(mean=0.0, std=0.02)
                if hasattr(module, "bias") and module.bias is not None:
                    module.bias.data.zero_()

    def forward(
        self,
        input_ids: torch.Tensor,
        labels: torch.Tensor = None,
        instruct_mode: bool = False,
        return_hidden: bool = False,
        return_dict: bool = False
    ):
        """
        Forward pass of NGEN3ForCausalLM.
        
        Args:
            input_ids (torch.Tensor): (B, T) input token IDs.
            labels (torch.Tensor, optional): Labels for computing the loss.
            instruct_mode (bool, optional): Whether to engage the instruct dense layer.
            return_hidden (bool, optional): If True, returns hidden states per block.
            return_dict (bool, optional): If True, returns a CausalLMOutputWithCrossAttentions.
        
        Returns:
            Either a tuple (logits, loss, [hidden_states]) or a CausalLMOutputWithCrossAttentions.
        """
        logits = self.ngen3(input_ids, instruct_mode=instruct_mode)
        loss = None
        if labels is not None:
            loss = F.cross_entropy(logits.view(-1, logits.size(-1)), labels.view(-1))
        if not return_dict:
            return (logits, loss)
        output = CausalLMOutputWithCrossAttentions(logits=logits, loss=loss)
        return output

class Block(nn.Module):
    def __init__(self, config: NGEN3Config):
        super().__init__()
        self.ln1 = nn.LayerNorm(config.n_embd)
        self.attn = CausalSelfAttention(config)
        self.ln2 = nn.LayerNorm(config.n_embd)
        self.mlp = MoEMLP(config) if config.use_moe else MLP(config)

    def forward(self, x: torch.Tensor) -> torch.Tensor:
        residual = x
        x = self.ln1(x)
        x = self.attn(x)
        x = residual + x
        residual = x
        x = self.ln2(x)
        x = self.mlp(x)
        return residual + x

class CausalSelfAttention(nn.Module):
    def __init__(self, config: NGEN3Config):
        super().__init__()
        assert config.n_embd % config.n_head == 0, "n_embd must be divisible by n_head"
        self.n_head = config.n_head
        self.head_dim = config.n_embd // config.n_head
        self.c_attn = nn.Linear(config.n_embd, 3 * config.n_embd)
        self.c_proj = nn.Linear(config.n_embd, config.n_embd)
        self.dropout = nn.Dropout(config.dropout)
        self.register_buffer("mask", torch.tril(torch.ones(config.block_size, config.block_size))
                             .view(1, 1, config.block_size, config.block_size))

    def forward(self, x: torch.Tensor) -> torch.Tensor:
        B, T, C = x.size()
        qkv = self.c_attn(x)  # (B, T, 3 * C)
        q, k, v = qkv.split(C, dim=2)
        q = q.view(B, T, self.n_head, self.head_dim).transpose(1, 2)
        k = k.view(B, T, self.n_head, self.head_dim).transpose(1, 2)
        v = v.view(B, T, self.n_head, self.head_dim).transpose(1, 2)
        q, k = apply_rotary_pos_emb(q, k)
        attn = (q @ k.transpose(-2, -1)) / math.sqrt(self.head_dim)
        attn = attn.masked_fill(self.mask[:, :, :T, :T] == 0, float('-inf'))
        attn = F.softmax(attn, dim=-1)
        attn = self.dropout(attn)
        y = attn @ v
        y = y.transpose(1, 2).contiguous().view(B, T, C)
        y = self.c_proj(y)
        return self.dropout(y)

class MLP(nn.Module):
    def __init__(self, config: NGEN3Config):
        super().__init__()
        self.fc1 = nn.Linear(config.n_embd, config.n_embd * 2)
        self.fc2 = nn.Linear(config.n_embd, config.n_embd)
        self.dropout = nn.Dropout(config.dropout)

    def forward(self, x: torch.Tensor) -> torch.Tensor:
        x_proj = self.fc1(x)
        x1, x2 = x_proj.chunk(2, dim=-1)
        x = F.silu(x1) * x2
        x = self.fc2(x)
        return self.dropout(x)

class ExpertMLP(nn.Module):
    def __init__(self, config: NGEN3Config):
        super().__init__()
        self.fc1 = nn.Linear(config.n_embd, config.n_embd * 2)
        self.fc2 = nn.Linear(config.n_embd, config.n_embd)
        self.dropout = nn.Dropout(config.dropout)

    def forward(self, x: torch.Tensor) -> torch.Tensor:
        x_proj = self.fc1(x)
        x1, x2 = x_proj.chunk(2, dim=-1)
        x = F.silu(x1) * x2
        x = self.fc2(x)
        return self.dropout(x)

class MoEMLP(nn.Module):
    def __init__(self, config: NGEN3Config):
        super().__init__()
        self.num_experts = config.num_experts
        self.experts = nn.ModuleList([ExpertMLP(config) for _ in range(self.num_experts)])
        self.gate = nn.Linear(config.n_embd, self.num_experts)
        self.dropout = nn.Dropout(config.dropout)

    def forward(self, x: torch.Tensor) -> torch.Tensor:
        gate_scores = self.gate(x)  # (B, T, num_experts)
        gate_probs = F.softmax(gate_scores, dim=-1)
        expert_outputs = torch.stack([expert(x) for expert in self.experts], dim=2)  # (B, T, num_experts, n_embd)
        gate_probs = gate_probs.unsqueeze(-1)
        output = torch.sum(gate_probs * expert_outputs, dim=2)
        return self.dropout(output)
