#!/usr/bin/env python3
"""
Utilities for automatically updating expected outputs in test files.

This module helps update test expectations based on actual outputs captured during test runs.
It works with the patching system in testing_utils.py that captures actual vs expected values.
"""

import ast
import re
from typing import Dict, List, Tuple, Optional, Any


def parse_captured_info(captured_info_content: str) -> List[Dict[str, Any]]:
    """
    Parse the captured_info.txt file generated by patched testing methods.

    Returns a list of dictionaries, each containing information about a test failure:
    - test_name: full test name (file::class::method)
    - test_file: path to test file
    - test_lineno: line number in test file
    - caller_lineno: line number where assertion was called
    - actual_value: the actual value (as formatted string)
    - expected_value: the expected value (as formatted string)
    - expected_expression: the variable/expression name for expected value
    """
    failures = []

    # Split by the separator between test failures
    test_blocks = captured_info_content.split("=" * 120)

    for block in test_blocks:
        if not block.strip():
            continue

        failure_info = {}

        # Extract test name
        test_match = re.search(r'test:\s*\n\s*([^\n]+)', block)
        if test_match:
            failure_info['test_name'] = test_match.group(1).strip()

        # Extract test context (file and line number)
        test_context_match = re.search(r'test context:\s*([^:]+):(\d+)', block)
        if test_context_match:
            failure_info['test_file'] = test_context_match.group(1).strip()
            failure_info['test_lineno'] = int(test_context_match.group(2))

        # Extract caller context (line number where assertion was made)
        caller_match = re.search(r'caller context:\s*[^:]+:(\d+)', block)
        if caller_match:
            failure_info['caller_lineno'] = int(caller_match.group(1))

        # Extract actual value
        actual_match = re.search(
            r'argument name: `(?:actual|first|output_text)`\s*\nargument expression: `([^`]+)`\s*\n\s*argument value:\s*\n\s*(.*?)(?=\n\s*-{80}|\Z)',
            block,
            re.DOTALL
        )
        if actual_match:
            failure_info['actual_expression'] = actual_match.group(1).strip()
            failure_info['actual_value'] = actual_match.group(2).strip()

        # Extract expected value
        expected_match = re.search(
            r'argument name: `(?:expected|second|EXPECTED_TEXT)`\s*\nargument expression: `([^`]+)`\s*\n\s*argument value:\s*\n\s*(.*?)(?=\n\s*={120}|\Z)',
            block,
            re.DOTALL
        )
        if expected_match:
            failure_info['expected_expression'] = expected_match.group(1).strip()
            failure_info['expected_value'] = expected_match.group(2).strip()

        if failure_info:
            failures.append(failure_info)

    return failures


def detect_value_type(value_str: str) -> str:
    """
    Detect the type of value from its string representation.

    Returns: 'torch_tensor', 'string', 'list_of_strings', 'list', 'dict', 'number', 'unknown'
    """
    value_str = value_str.strip()

    # Torch tensor: starts with [ and has comma-separated numbers
    # Could be nested like [[-0.15, 0.03], [0.28, 0.11]]
    if value_str.startswith('[') and value_str.endswith(']'):
        # Try to parse as nested numeric structure
        try:
            # Check if it looks like a tensor (numbers with optional signs and decimals)
            content = value_str[1:-1].strip()
            if re.match(r'^[\[\],\s\-\d.e+]+$', content):
                return 'torch_tensor'
        except:
            pass

        # Check for list of strings
        if value_str.startswith('["') or value_str.startswith("['"):
            return 'list_of_strings'

        return 'list'

    # String
    if (value_str.startswith('"') and value_str.endswith('"')) or \
            (value_str.startswith("'") and value_str.endswith("'")):
        return 'string'

    # Number
    if re.match(r'^-?\d+\.?\d*(?:[eE][+-]?\d+)?$', value_str):
        return 'number'

    # Dict
    if value_str.startswith('{') and value_str.endswith('}'):
        return 'dict'

    return 'unknown'


def find_expected_value_in_code(
        file_path: str,
        line_number: int,
        expected_expression: str,
        value_type: str
) -> Optional[Tuple[int, int, str]]:
    """
    Find where the expected value is defined in the test file.

    Returns: (start_line, end_line, original_text) or None if not found

    The function looks for the expected value definition by:
    1. Checking the lines around the assertion for inline definitions
    2. Looking backwards for variable assignments
    3. Handling multi-line tensor/list definitions
    """
    with open(file_path, 'r') as f:
        lines = f.readlines()

    # Start from the assertion line and look backwards
    search_start = max(0, line_number - 50)  # Look up to 50 lines back
    search_end = min(len(lines), line_number + 5)  # And a few lines forward

    # Case 1: Inline definition in the assertion itself
    # e.g., torch.testing.assert_close(actual, torch.tensor([1, 2, 3]))
    for i in range(line_number - 1, search_end):
        if i >= len(lines):
            break
        line = lines[i]

        # Check if expected_expression is defined inline
        if value_type == 'torch_tensor':
            # Look for torch.tensor([...])
            pattern = rf'{re.escape(expected_expression)}\s*=\s*torch\.tensor\s*\('
            match = re.search(pattern, line)
            if match:
                # Found inline definition, need to find the closing parenthesis
                return _extract_multiline_expression(lines, i, match.start())

    # Case 2: Variable assignment before the assertion
    # e.g., expected_slice = torch.tensor([...])
    pattern = rf'^\s*{re.escape(expected_expression)}\s*=\s*'

    for i in range(line_number - 1, search_start - 1, -1):
        if i < 0:
            break
        line = lines[i]

        if re.search(pattern, line):
            # Found the assignment, now extract the full value (could be multi-line)
            return _extract_multiline_expression(lines, i, 0)

    return None


def _extract_multiline_expression(
        lines: List[str],
        start_line: int,
        start_col: int = 0
) -> Tuple[int, int, str]:
    """
    Extract a potentially multi-line expression starting from start_line.

    Handles:
    - torch.tensor([...]) with nested brackets
    - Lists ["...", "..."]
    - Multi-line definitions

    Returns: (start_line, end_line, extracted_text)
    """
    # Count brackets/parentheses to find where expression ends
    text = ""
    bracket_count = 0
    paren_count = 0
    in_string = False
    string_char = None

    for line_idx in range(start_line, len(lines)):
        line = lines[line_idx]

        # For first line, start from start_col
        if line_idx == start_line:
            line_part = line[start_col:]
        else:
            line_part = line

        text += line_part

        # Parse character by character to handle strings and brackets
        for char in line_part:
            if char in ('"', "'") and not in_string:
                in_string = True
                string_char = char
            elif char == string_char and in_string:
                in_string = False
                string_char = None
            elif not in_string:
                if char == '[':
                    bracket_count += 1
                elif char == ']':
                    bracket_count -= 1
                elif char == '(':
                    paren_count += 1
                elif char == ')':
                    paren_count -= 1

        # Check if we've closed all brackets and parentheses
        # Also check if line ends with a comma or has closing bracket/paren
        line_stripped = line_part.rstrip()
        if bracket_count == 0 and paren_count == 0:
            # Check if this line ends the expression
            if line_stripped.endswith(')') or line_stripped.endswith(']') or \
                    line_stripped.endswith(','):
                return (start_line, line_idx, text.rstrip())
            # If next line doesn't continue the expression, we're done
            if line_idx + 1 < len(lines):
                next_line = lines[line_idx + 1].strip()
                if next_line and not next_line.startswith((',', ']', ')')):
                    return (start_line, line_idx, text.rstrip())

    return (start_line, len(lines) - 1, text.rstrip())


def format_torch_tensor_for_code(value_str: str, indent_level: int = 0) -> str:
    """
    Format a torch tensor value string into proper Python code.

    Input: "[-0.1552, 0.0314, -0.3233]" or multi-line tensor representation
    Output: Properly formatted torch.tensor([...]) code
    """
    # Remove any extra whitespace and normalize
    value_str = value_str.strip()

    # Check if it's already a multi-line format (from captured_info)
    is_multiline = '\n' in value_str

    if is_multiline:
        # The value is already formatted by _format_tensor() from testing_utils
        # It looks like:
        # [
        #     [-0.1552, 0.0314, -0.3233],
        #     [0.2886, 0.1141, -0.5706],
        # ]
        # We need to apply proper indentation
        lines = value_str.split('\n')
        indented_lines = []
        for line in lines:
            stripped = line.lstrip()
            if stripped:
                indented_lines.append(' ' * (indent_level * 4) + stripped)
            else:
                indented_lines.append('')
        return '\n'.join(indented_lines)
    else:
        # Single line tensor - convert to multi-line if it's 2D
        indent = ' ' * (indent_level * 4)

        # Try to parse as nested list and reformat
        try:
            # For 2D tensors like [[1,2,3], [4,5,6]], make it multi-line
            if value_str.startswith('[[') and value_str.endswith(']]'):
                # Extract inner lists
                inner = value_str[1:-1].strip()  # Remove outer []
                # Split by '], [' pattern
                rows = []
                depth = 0
                current_row = ''
                for char in inner:
                    if char == '[':
                        depth += 1
                    elif char == ']':
                        depth -= 1
                        if depth == 0:
                            rows.append('[' + current_row + ']')
                            current_row = ''
                            continue
                    if depth > 0:
                        current_row += char

                # Format as multi-line
                formatted = indent + '[\n'
                for row in rows:
                    formatted += indent + '    ' + row + ',\n'
                formatted += indent + ']'
                return formatted
            else:
                # 1D tensor, keep as single line
                return f"{indent}{value_str}"
        except:
            # Fallback: return as-is with indentation
            return f"{indent}{value_str}"


def update_expected_value_in_file(
        file_path: str,
        start_line: int,
        end_line: int,
        new_value: str,
        value_type: str
) -> bool:
    """
    Update the expected value in the test file.

    Returns True if successful, False otherwise.
    """
    with open(file_path, 'r') as f:
        lines = f.readlines()

    # Get the original text to extract the full pattern
    original_text = ''.join(lines[start_line:end_line + 1])

    # Get the indentation of the original definition
    original_line = lines[start_line]
    indent_match = re.match(r'^(\s*)', original_line)
    indent = indent_match.group(1) if indent_match else ''
    indent_level = len(indent) // 4

    # Extract the variable assignment part (e.g., "expected_slice = ")
    assignment_match = re.match(r'^(\s*)(\w+\s*=\s*)', original_line)
    assignment_prefix = ''
    if assignment_match:
        assignment_prefix = assignment_match.group(2)

    # Extract any method chaining at the end (e.g., ".to(torch_device)")
    method_chain_suffix = ''
    if value_type == 'torch_tensor':
        # Look for patterns like ).to(...) or ).cuda() etc.
        chain_match = re.search(r'(\)\s*\.\s*\w+\([^)]*\))', original_text)
        if chain_match:
            method_chain_suffix = chain_match.group(1)

    # Format the new value appropriately
    if value_type == 'torch_tensor':
        # Parse the new value to reformat it properly
        formatted_tensor = format_torch_tensor_for_code(new_value, indent_level + 1)

        # Check if original was torch.tensor(...) or just [...]
        if 'torch.tensor' in original_text:
            # Build the full replacement with proper structure
            formatted_value = f"{indent}{assignment_prefix}torch.tensor(\n"
            formatted_value += f"{formatted_tensor}\n"
            formatted_value += f"{indent}){method_chain_suffix}"
        else:
            # Just update the tensor values directly
            formatted_value = f"{indent}{assignment_prefix}{formatted_tensor}"
    elif value_type == 'string':
        formatted_value = f"{indent}{assignment_prefix}{new_value}"
    elif value_type == 'list_of_strings':
        formatted_value = f"{indent}{assignment_prefix}{new_value}"
    else:
        formatted_value = f"{indent}{assignment_prefix}{new_value}"

    # Replace the lines
    new_lines = lines[:start_line] + [formatted_value + '\n'] + lines[end_line + 1:]

    # Write back to file
    with open(file_path, 'w') as f:
        f.writelines(new_lines)

    return True


def process_captured_failures(
        captured_info_path: str,
        dry_run: bool = True
) -> Dict[str, List[str]]:
    """
    Process all captured test failures and update expected values.

    Args:
        captured_info_path: Path to the captured_info.txt file
        dry_run: If True, only report what would be changed without modifying files

    Returns:
        Dictionary mapping file paths to list of changes made
    """
    with open(captured_info_path, 'r') as f:
        content = f.read()

    failures = parse_captured_info(content)
    changes = {}

    for failure in failures:
        test_file = failure.get('test_file')
        if not test_file:
            continue

        expected_expr = failure.get('expected_expression')
        actual_value = failure.get('actual_value')

        if not expected_expr or not actual_value:
            continue

        # Detect value type
        value_type = detect_value_type(actual_value)

        # Find where expected value is defined
        location = find_expected_value_in_code(
            test_file,
            failure.get('test_lineno', 0),
            expected_expr,
            value_type
        )

        if location:
            start_line, end_line, original_text = location

            change_desc = (
                f"Line {start_line + 1}-{end_line + 1}: "
                f"Update {expected_expr} from:\n{original_text}\nto:\n{actual_value}"
            )

            if test_file not in changes:
                changes[test_file] = []
            changes[test_file].append(change_desc)

            if not dry_run:
                update_expected_value_in_file(
                    test_file,
                    start_line,
                    end_line,
                    actual_value,
                    value_type
                )

    return changes


if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(
        description="Update expected values in test files based on captured failures"
    )
    parser.add_argument(
        "captured_info",
        help="Path to captured_info.txt file"
    )
    parser.add_argument(
        "--apply",
        action="store_true",
        help="Actually apply changes (default is dry-run)"
    )

    args = parser.parse_args()

    changes = process_captured_failures(
        args.captured_info,
        dry_run=not args.apply
    )

    if changes:
        print("Changes to be made:" if not args.apply else "Changes made:")
        for file_path, file_changes in changes.items():
            print(f"\n{file_path}:")
            for change in file_changes:
                print(f"  {change}")
    else:
        print("No changes detected.")