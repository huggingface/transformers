<!--Copyright 2022 The HuggingFace Team. All rights reserved.

Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
the License. You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
specific language governing permissions and limitations under the License.

âš ï¸ Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be
rendered properly in your Markdown viewer.

-->

# ì´ë¯¸ì§€ ë¶„ë¥˜[[image-classification]]

[[open-in-colab]]

<Youtube id="tjAIM7BOYhw"/>

ì´ë¯¸ì§€ ë¶„ë¥˜ëŠ” ì´ë¯¸ì§€ì— ë ˆì´ë¸” ë˜ëŠ” í´ë˜ìŠ¤ë¥¼ í• ë‹¹í•©ë‹ˆë‹¤. í…ìŠ¤íŠ¸ ë˜ëŠ” ì˜¤ë””ì˜¤ ë¶„ë¥˜ì™€ ë‹¬ë¦¬ ì…ë ¥ì€
ì´ë¯¸ì§€ë¥¼ êµ¬ì„±í•˜ëŠ” í”½ì…€ ê°’ì…ë‹ˆë‹¤. ì´ë¯¸ì§€ ë¶„ë¥˜ì—ëŠ” ìì—°ì¬í•´ í›„ í”¼í•´ ê°ì§€, ë†ì‘ë¬¼ ê±´ê°• ëª¨ë‹ˆí„°ë§, ì˜ë£Œ ì´ë¯¸ì§€ì—ì„œ ì§ˆë³‘ì˜ ì§•í›„ ê²€ì‚¬ ì§€ì› ë“±
ë‹¤ì–‘í•œ ì‘ìš© ì‚¬ë¡€ê°€ ìˆìŠµë‹ˆë‹¤.

ì´ ê°€ì´ë“œì—ì„œëŠ” ë‹¤ìŒì„ ì„¤ëª…í•©ë‹ˆë‹¤:

1. [Food-101](https://huggingface.co/datasets/food101) ë°ì´í„° ì„¸íŠ¸ì—ì„œ [ViT](model_doc/vit)ë¥¼ ë¯¸ì„¸ ì¡°ì •í•˜ì—¬ ì´ë¯¸ì§€ì—ì„œ ì‹í’ˆ í•­ëª©ì„ ë¶„ë¥˜í•©ë‹ˆë‹¤.
2. ì¶”ë¡ ì„ ìœ„í•´ ë¯¸ì„¸ ì¡°ì • ëª¨ë¸ì„ ì‚¬ìš©í•©ë‹ˆë‹¤.

<Tip>
ì´ íŠœí† ë¦¬ì–¼ì—ì„œ ì„¤ëª…í•˜ëŠ” ì‘ì—…ì€ ë‹¤ìŒ ëª¨ë¸ ì•„í‚¤í…ì²˜ì— ì˜í•´ ì§€ì›ë©ë‹ˆë‹¤:

<!--This tip is automatically generated by `make fix-copies`, do not fill manually!-->

[BEiT](../model_doc/beit), [BiT](../model_doc/bit), [ConvNeXT](../model_doc/convnext), [ConvNeXTV2](../model_doc/convnextv2), [CvT](../model_doc/cvt), [Data2VecVision](../model_doc/data2vec-vision), [DeiT](../model_doc/deit), [DiNAT](../model_doc/dinat), [EfficientFormer](../model_doc/efficientformer), [EfficientNet](../model_doc/efficientnet), [FocalNet](../model_doc/focalnet), [ImageGPT](../model_doc/imagegpt), [LeViT](../model_doc/levit), [MobileNetV1](../model_doc/mobilenet_v1), [MobileNetV2](../model_doc/mobilenet_v2), [MobileViT](../model_doc/mobilevit), [NAT](../model_doc/nat), [Perceiver](../model_doc/perceiver), [PoolFormer](../model_doc/poolformer), [RegNet](../model_doc/regnet), [ResNet](../model_doc/resnet), [SegFormer](../model_doc/segformer), [Swin Transformer](../model_doc/swin), [Swin Transformer V2](../model_doc/swinv2), [VAN](../model_doc/van), [ViT](../model_doc/vit), [ViT Hybrid](../model_doc/vit_hybrid), [ViTMSN](../model_doc/vit_msn)
<!--End of the generated tip-->

</Tip>

ì‹œì‘í•˜ê¸° ì „ì—, í•„ìš”í•œ ëª¨ë“  ë¼ì´ë¸ŒëŸ¬ë¦¬ê°€ ì„¤ì¹˜ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸í•˜ì„¸ìš”:

```bash
pip install transformers datasets evaluate
```

Hugging Face ê³„ì •ì— ë¡œê·¸ì¸í•˜ì—¬ ëª¨ë¸ì„ ì—…ë¡œë“œí•˜ê³  ì»¤ë®¤ë‹ˆí‹°ì— ê³µìœ í•˜ëŠ” ê²ƒì„ ê¶Œì¥í•©ë‹ˆë‹¤. ë©”ì‹œì§€ê°€ í‘œì‹œë˜ë©´, í† í°ì„ ì…ë ¥í•˜ì—¬ ë¡œê·¸ì¸í•˜ì„¸ìš”:

```py
>>> from huggingface_hub import notebook_login

>>> notebook_login()
```

## Food-101 ë°ì´í„° ì„¸íŠ¸ ê°€ì ¸ì˜¤ê¸°[[load-food101-dataset]]

ğŸ¤— Datasets ë¼ì´ë¸ŒëŸ¬ë¦¬ì—ì„œ Food-101 ë°ì´í„° ì„¸íŠ¸ì˜ ë” ì‘ì€ ë¶€ë¶„ ì§‘í•©ì„ ê°€ì ¸ì˜¤ëŠ” ê²ƒìœ¼ë¡œ ì‹œì‘í•©ë‹ˆë‹¤. ì´ë ‡ê²Œ í•˜ë©´ ì „ì²´ ë°ì´í„° ì„¸íŠ¸ì— ëŒ€í•œ
í›ˆë ¨ì— ë§ì€ ì‹œê°„ì„ í• ì• í•˜ê¸° ì „ì— ì‹¤í—˜ì„ í†µí•´ ëª¨ë“  ê²ƒì´ ì œëŒ€ë¡œ ì‘ë™í•˜ëŠ”ì§€ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

```py
>>> from datasets import load_dataset

>>> food = load_dataset("food101", split="train[:5000]")
```

ë°ì´í„° ì„¸íŠ¸ì˜ `train`ì„ [`~datasets.Dataset.train_test_split`] ë©”ì†Œë“œë¥¼ ì‚¬ìš©í•˜ì—¬ í›ˆë ¨ ë° í…ŒìŠ¤íŠ¸ ì„¸íŠ¸ë¡œ ë¶„í• í•˜ì„¸ìš”:

```py
>>> food = food.train_test_split(test_size=0.2)
```

ê·¸ë¦¬ê³  ì˜ˆì‹œë¥¼ ì‚´í´ë³´ì„¸ìš”:

```py
>>> food["train"][0]
{'image': <PIL.JpegImagePlugin.JpegImageFile image mode=RGB size=512x512 at 0x7F52AFC8AC50>,
 'label': 79}
```

ë°ì´í„° ì„¸íŠ¸ì˜ ê° ì˜ˆì œì—ëŠ” ë‘ ê°œì˜ í•„ë“œê°€ ìˆìŠµë‹ˆë‹¤:

- `image`: ì‹í’ˆ í•­ëª©ì˜ PIL ì´ë¯¸ì§€
- `label`: ì‹í’ˆ í•­ëª©ì˜ ë ˆì´ë¸” í´ë˜ìŠ¤

ëª¨ë¸ì´ ë ˆì´ë¸” IDì—ì„œ ë ˆì´ë¸” ì´ë¦„ì„ ì‰½ê²Œ ê°€ì ¸ì˜¬ ìˆ˜ ìˆë„ë¡
ë ˆì´ë¸” ì´ë¦„ì„ ì •ìˆ˜ë¡œ ë§¤í•‘í•˜ê³ , ì •ìˆ˜ë¥¼ ë ˆì´ë¸” ì´ë¦„ìœ¼ë¡œ ë§¤í•‘í•˜ëŠ” ì‚¬ì „ì„ ë§Œë“œì„¸ìš”:

```py
>>> labels = food["train"].features["label"].names
>>> label2id, id2label = dict(), dict()
>>> for i, label in enumerate(labels):
...     label2id[label] = str(i)
...     id2label[str(i)] = label
```

ì´ì œ ë ˆì´ë¸” IDë¥¼ ë ˆì´ë¸” ì´ë¦„ìœ¼ë¡œ ë³€í™˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:

```py
>>> id2label[str(79)]
'prime_rib'
```

## ì „ì²˜ë¦¬[[preprocess]]

ë‹¤ìŒ ë‹¨ê³„ëŠ” ì´ë¯¸ì§€ë¥¼ í…ì„œë¡œ ì²˜ë¦¬í•˜ê¸° ìœ„í•´ ViT ì´ë¯¸ì§€ í”„ë¡œì„¸ì„œë¥¼ ê°€ì ¸ì˜¤ëŠ” ê²ƒì…ë‹ˆë‹¤:

```py
>>> from transformers import AutoImageProcessor

>>> checkpoint = "google/vit-base-patch16-224-in21k"
>>> image_processor = AutoImageProcessor.from_pretrained(checkpoint)
```

<frameworkcontent>
<pt>
ì´ë¯¸ì§€ì— ëª‡ ê°€ì§€ ì´ë¯¸ì§€ ë³€í™˜ì„ ì ìš©í•˜ì—¬ ê³¼ì í•©ì— ëŒ€í•´ ëª¨ë¸ì„ ë” ê²¬ê³ í•˜ê²Œ ë§Œë“­ë‹ˆë‹¤. ì—¬ê¸°ì„œ Torchvisionì˜ [`transforms`](https://pytorch.org/vision/stable/transforms.html) ëª¨ë“ˆì„ ì‚¬ìš©í•˜ì§€ë§Œ, ì›í•˜ëŠ” ì´ë¯¸ì§€ ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì‚¬ìš©í•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤.

ì´ë¯¸ì§€ì˜ ì„ì˜ ë¶€ë¶„ì„ í¬ë¡­í•˜ê³  í¬ê¸°ë¥¼ ì¡°ì •í•œ ë‹¤ìŒ, ì´ë¯¸ì§€ í‰ê· ê³¼ í‘œì¤€ í¸ì°¨ë¡œ ì •ê·œí™”í•˜ì„¸ìš”:

```py
>>> from torchvision.transforms import RandomResizedCrop, Compose, Normalize, ToTensor

>>> normalize = Normalize(mean=image_processor.image_mean, std=image_processor.image_std)
>>> size = (
...     image_processor.size["shortest_edge"]
...     if "shortest_edge" in image_processor.size
...     else (image_processor.size["height"], image_processor.size["width"])
... )
>>> _transforms = Compose([RandomResizedCrop(size), ToTensor(), normalize])
```

ê·¸ëŸ° ë‹¤ìŒ ì „ì²˜ë¦¬ í•¨ìˆ˜ë¥¼ ë§Œë“¤ì–´ ë³€í™˜ì„ ì ìš©í•˜ê³  ì´ë¯¸ì§€ì˜ `pixel_values`(ëª¨ë¸ì— ëŒ€í•œ ì…ë ¥)ë¥¼ ë°˜í™˜í•˜ì„¸ìš”:

```py
>>> def transforms(examples):
...     examples["pixel_values"] = [_transforms(img.convert("RGB")) for img in examples["image"]]
...     del examples["image"]
...     return examples
```

ì „ì²´ ë°ì´í„° ì„¸íŠ¸ì— ì „ì²˜ë¦¬ ê¸°ëŠ¥ì„ ì ìš©í•˜ë ¤ë©´ ğŸ¤— Datasets [`~datasets.Dataset.with_transform`]ì„ ì‚¬ìš©í•©ë‹ˆë‹¤. ë°ì´í„° ì„¸íŠ¸ì˜ ìš”ì†Œë¥¼ ê°€ì ¸ì˜¬ ë•Œ ë³€í™˜ì´ ì¦‰ì‹œ ì ìš©ë©ë‹ˆë‹¤:

```py
>>> food = food.with_transform(transforms)
```

ì´ì œ [`DefaultDataCollator`]ë¥¼ ì‚¬ìš©í•˜ì—¬ ì˜ˆì œ ë°°ì¹˜ë¥¼ ë§Œë“­ë‹ˆë‹¤. ğŸ¤— Transformersì˜ ë‹¤ë¥¸ ë°ì´í„° ì½œë ˆì´í„°ì™€ ë‹¬ë¦¬, `DefaultDataCollator`ëŠ” íŒ¨ë”©ê³¼ ê°™ì€ ì¶”ê°€ì ì¸ ì „ì²˜ë¦¬ë¥¼ ì ìš©í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.

```py
>>> from transformers import DefaultDataCollator

>>> data_collator = DefaultDataCollator()
```
</pt>
</frameworkcontent>


<frameworkcontent>
<tf>

ê³¼ì í•©ì„ ë°©ì§€í•˜ê³  ëª¨ë¸ì„ ë³´ë‹¤ ê²¬ê³ í•˜ê²Œ ë§Œë“¤ê¸° ìœ„í•´ ë°ì´í„° ì„¸íŠ¸ì˜ í›ˆë ¨ ë¶€ë¶„ì— ë°ì´í„° ì¦ê°•ì„ ì¶”ê°€í•©ë‹ˆë‹¤.
ì—¬ê¸°ì„œ Keras ì „ì²˜ë¦¬ ë ˆì´ì–´ë¡œ í›ˆë ¨ ë°ì´í„°ì— ëŒ€í•œ ë³€í™˜(ë°ì´í„° ì¦ê°• í¬í•¨)ê³¼
ê²€ì¦ ë°ì´í„°ì— ëŒ€í•œ ë³€í™˜(ì¤‘ì•™ í¬ë¡œí•‘, í¬ê¸° ì¡°ì •, ì •ê·œí™”ë§Œ)ì„ ì •ì˜í•©ë‹ˆë‹¤. 
`tf.image` ë˜ëŠ” ë‹¤ë¥¸ ì›í•˜ëŠ” ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

```py
>>> from tensorflow import keras
>>> from tensorflow.keras import layers

>>> size = (image_processor.size["height"], image_processor.size["width"])

>>> train_data_augmentation = keras.Sequential(
...     [
...         layers.RandomCrop(size[0], size[1]),
...         layers.Rescaling(scale=1.0 / 127.5, offset=-1),
...         layers.RandomFlip("horizontal"),
...         layers.RandomRotation(factor=0.02),
...         layers.RandomZoom(height_factor=0.2, width_factor=0.2),
...     ],
...     name="train_data_augmentation",
... )

>>> val_data_augmentation = keras.Sequential(
...     [
...         layers.CenterCrop(size[0], size[1]),
...         layers.Rescaling(scale=1.0 / 127.5, offset=-1),
...     ],
...     name="val_data_augmentation",
... )
```

ë‹¤ìŒìœ¼ë¡œ í•œ ë²ˆì— í•˜ë‚˜ì˜ ì´ë¯¸ì§€ê°€ ì•„ë‹ˆë¼ ì´ë¯¸ì§€ ë°°ì¹˜ì— ì ì ˆí•œ ë³€í™˜ì„ ì ìš©í•˜ëŠ” í•¨ìˆ˜ë¥¼ ë§Œë“­ë‹ˆë‹¤.

```py
>>> import numpy as np
>>> import tensorflow as tf
>>> from PIL import Image


>>> def convert_to_tf_tensor(image: Image):
...     np_image = np.array(image)
...     tf_image = tf.convert_to_tensor(np_image)
...     # `expand_dims()` is used to add a batch dimension since
...     # the TF augmentation layers operates on batched inputs.
...     return tf.expand_dims(tf_image, 0)


>>> def preprocess_train(example_batch):
...     """Apply train_transforms across a batch."""
...     images = [
...         train_data_augmentation(convert_to_tf_tensor(image.convert("RGB"))) for image in example_batch["image"]
...     ]
...     example_batch["pixel_values"] = [tf.transpose(tf.squeeze(image)) for image in images]
...     return example_batch


... def preprocess_val(example_batch):
...     """Apply val_transforms across a batch."""
...     images = [
...         val_data_augmentation(convert_to_tf_tensor(image.convert("RGB"))) for image in example_batch["image"]
...     ]
...     example_batch["pixel_values"] = [tf.transpose(tf.squeeze(image)) for image in images]
...     return example_batch
```

ğŸ¤— Datasets [`~datasets.Dataset.set_transform`]ë¥¼ ì‚¬ìš©í•˜ì—¬ ì¦‰ì‹œ ë³€í™˜ì„ ì ìš©í•˜ì„¸ìš”:

```py
food["train"].set_transform(preprocess_train)
food["test"].set_transform(preprocess_val)
```

ìµœì¢… ì „ì²˜ë¦¬ ë‹¨ê³„ë¡œ `DefaultDataCollator`ë¥¼ ì‚¬ìš©í•˜ì—¬ ì˜ˆì œ ë°°ì¹˜ë¥¼ ë§Œë“­ë‹ˆë‹¤. ğŸ¤— Transformersì˜ ë‹¤ë¥¸ ë°ì´í„° ì½œë ˆì´í„°ì™€ ë‹¬ë¦¬
`DefaultDataCollator`ëŠ” íŒ¨ë”©ê³¼ ê°™ì€ ì¶”ê°€ ì „ì²˜ë¦¬ë¥¼ ì ìš©í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.

```py
>>> from transformers import DefaultDataCollator

>>> data_collator = DefaultDataCollator(return_tensors="tf")
```
</tf>
</frameworkcontent>

## í‰ê°€[[evaluate]]

í›ˆë ¨ ì¤‘ì— í‰ê°€ ì§€í‘œë¥¼ í¬í•¨í•˜ë©´ ëª¨ë¸ì˜ ì„±ëŠ¥ì„ í‰ê°€í•˜ëŠ” ë° ë„ì›€ì´ ë˜ëŠ” ê²½ìš°ê°€ ë§ìŠµë‹ˆë‹¤.
ğŸ¤— [Evaluate](https://huggingface.co/docs/evaluate/index) ë¼ì´ë¸ŒëŸ¬ë¦¬ë¡œ í‰ê°€ ë°©ë²•ì„ ë¹ ë¥´ê²Œ ê°€ì ¸ì˜¬ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ ì‘ì—…ì—ì„œëŠ” 
[accuracy](https://huggingface.co/spaces/evaluate-metric/accuracy) í‰ê°€ ì§€í‘œë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤. (ğŸ¤— Evaluate [ë¹ ë¥¸ ë‘˜ëŸ¬ë³´ê¸°](https://huggingface.co/docs/evaluate/a_quick_tour)ë¥¼ ì°¸ì¡°í•˜ì—¬ í‰ê°€ ì§€í‘œë¥¼ ê°€ì ¸ì˜¤ê³  ê³„ì‚°í•˜ëŠ” ë°©ë²•ì— ëŒ€í•´ ìì„¸íˆ ì•Œì•„ë³´ì„¸ìš”):

```py
>>> import evaluate

>>> accuracy = evaluate.load("accuracy")
```

ê·¸ëŸ° ë‹¤ìŒ ì˜ˆì¸¡ê³¼ ë ˆì´ë¸”ì„ [`~evaluate.EvaluationModule.compute`]ì— ì „ë‹¬í•˜ì—¬ ì •í™•ë„ë¥¼ ê³„ì‚°í•˜ëŠ” í•¨ìˆ˜ë¥¼ ë§Œë“­ë‹ˆë‹¤:

```py
>>> import numpy as np


>>> def compute_metrics(eval_pred):
...     predictions, labels = eval_pred
...     predictions = np.argmax(predictions, axis=1)
...     return accuracy.compute(predictions=predictions, references=labels)
```

ì´ì œ `compute_metrics` í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•  ì¤€ë¹„ê°€ ë˜ì—ˆìœ¼ë©°, í›ˆë ¨ì„ ì„¤ì •í•˜ë©´ ì´ í•¨ìˆ˜ë¡œ ë˜ëŒì•„ì˜¬ ê²ƒì…ë‹ˆë‹¤.

## í›ˆë ¨[[train]]

<frameworkcontent>
<pt>
<Tip>

[`Trainer`]ë¥¼ ì‚¬ìš©í•˜ì—¬ ëª¨ë¸ì„ ë¯¸ì„¸ ì¡°ì •í•˜ëŠ” ë°©ë²•ì— ìµìˆ™í•˜ì§€ ì•Šì€ ê²½ìš°, [ì—¬ê¸°](../training#train-with-pytorch-trainer)ì—ì„œ ê¸°ë³¸ íŠœí† ë¦¬ì–¼ì„ í™•ì¸í•˜ì„¸ìš”!

</Tip>

ì´ì œ ëª¨ë¸ì„ í›ˆë ¨ì‹œí‚¬ ì¤€ë¹„ê°€ ë˜ì—ˆìŠµë‹ˆë‹¤! [`AutoModelForImageClassification`]ë¡œ ViTë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤. ì˜ˆìƒë˜ëŠ” ë ˆì´ë¸” ìˆ˜, ë ˆì´ë¸” ë§¤í•‘ ë° ë ˆì´ë¸” ìˆ˜ë¥¼ ì§€ì •í•˜ì„¸ìš”:

```py
>>> from transformers import AutoModelForImageClassification, TrainingArguments, Trainer

>>> model = AutoModelForImageClassification.from_pretrained(
...     checkpoint,
...     num_labels=len(labels),
...     id2label=id2label,
...     label2id=label2id,
... )
```

ì´ì œ ì„¸ ë‹¨ê³„ë§Œ ê±°ì¹˜ë©´ ëì…ë‹ˆë‹¤:

1. [`TrainingArguments`]ì—ì„œ í›ˆë ¨ í•˜ì´í¼íŒŒë¼ë¯¸í„°ë¥¼ ì •ì˜í•˜ì„¸ìš”. `image` ì—´ì´ ì‚­ì œë˜ê¸° ë•Œë¬¸ì— ë¯¸ì‚¬ìš© ì—´ì„ ì œê±°í•˜ì§€ ì•ŠëŠ” ê²ƒì´ ì¤‘ìš”í•©ë‹ˆë‹¤. `image` ì—´ì´ ì—†ìœ¼ë©´ `pixel_values`ì„ ìƒì„±í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì´ ë™ì‘ì„ ë°©ì§€í•˜ë ¤ë©´ `remove_unused_columns=False`ë¡œ ì„¤ì •í•˜ì„¸ìš”! ë‹¤ë¥¸ ìœ ì¼í•œ í•„ìˆ˜ ë§¤ê°œë³€ìˆ˜ëŠ” ëª¨ë¸ ì €ì¥ ìœ„ì¹˜ë¥¼ ì§€ì •í•˜ëŠ” `output_dir`ì…ë‹ˆë‹¤. `push_to_hub=True`ë¡œ ì„¤ì •í•˜ë©´ ì´ ëª¨ë¸ì„ í—ˆë¸Œì— í‘¸ì‹œí•©ë‹ˆë‹¤(ëª¨ë¸ì„ ì—…ë¡œë“œí•˜ë ¤ë©´ Hugging Faceì— ë¡œê·¸ì¸í•´ì•¼ í•©ë‹ˆë‹¤). ê° ì—í­ì´ ëë‚  ë•Œë§ˆë‹¤, [`Trainer`]ê°€ ì •í™•ë„ë¥¼ í‰ê°€í•˜ê³  í›ˆë ¨ ì²´í¬í¬ì¸íŠ¸ë¥¼ ì €ì¥í•©ë‹ˆë‹¤.
2. [`Trainer`]ì— ëª¨ë¸, ë°ì´í„° ì„¸íŠ¸, í† í¬ë‚˜ì´ì €, ë°ì´í„° ì½œë ˆì´í„° ë° `compute_metrics` í•¨ìˆ˜ì™€ í•¨ê»˜ í›ˆë ¨ ì¸ìˆ˜ë¥¼ ì „ë‹¬í•˜ì„¸ìš”.
3. [`~Trainer.train`]ì„ í˜¸ì¶œí•˜ì—¬ ëª¨ë¸ì„ ë¯¸ì„¸ ì¡°ì •í•˜ì„¸ìš”.

```py
>>> training_args = TrainingArguments(
...     output_dir="my_awesome_food_model",
...     remove_unused_columns=False,
...     eval_strategy="epoch",
...     save_strategy="epoch",
...     learning_rate=5e-5,
...     per_device_train_batch_size=16,
...     gradient_accumulation_steps=4,
...     per_device_eval_batch_size=16,
...     num_train_epochs=3,
...     warmup_ratio=0.1,
...     logging_steps=10,
...     load_best_model_at_end=True,
...     metric_for_best_model="accuracy",
...     push_to_hub=True,
... )

>>> trainer = Trainer(
...     model=model,
...     args=training_args,
...     data_collator=data_collator,
...     train_dataset=food["train"],
...     eval_dataset=food["test"],
...     tokenizer=image_processor,
...     compute_metrics=compute_metrics,
... )

>>> trainer.train()
```

í›ˆë ¨ì´ ì™„ë£Œë˜ë©´, ëª¨ë“  ì‚¬ëŒì´ ëª¨ë¸ì„ ì‚¬ìš©í•  ìˆ˜ ìˆë„ë¡ [`~transformers.Trainer.push_to_hub`] ë©”ì†Œë“œë¡œ ëª¨ë¸ì„ í—ˆë¸Œì— ê³µìœ í•˜ì„¸ìš”:

```py
>>> trainer.push_to_hub()
```
</pt>
</frameworkcontent>

<frameworkcontent>
<tf>

<Tip>

Kerasë¥¼ ì‚¬ìš©í•˜ì—¬ ëª¨ë¸ì„ ë¯¸ì„¸ ì¡°ì •í•˜ëŠ” ë°©ë²•ì— ìµìˆ™í•˜ì§€ ì•Šì€ ê²½ìš°, ë¨¼ì € [ê¸°ë³¸ íŠœí† ë¦¬ì–¼](./training#train-a-tensorflow-model-with-keras)ì„ í™•ì¸í•˜ì„¸ìš”!

</Tip>

TensorFlowì—ì„œ ëª¨ë¸ì„ ë¯¸ì„¸ ì¡°ì •í•˜ë ¤ë©´ ë‹¤ìŒ ë‹¨ê³„ë¥¼ ë”°ë¥´ì„¸ìš”:
1. í›ˆë ¨ í•˜ì´í¼íŒŒë¼ë¯¸í„°ë¥¼ ì •ì˜í•˜ê³  ì˜µí‹°ë§ˆì´ì €ì™€ í•™ìŠµë¥  ìŠ¤ì¼€ì¥´ì„ ì„¤ì •í•©ë‹ˆë‹¤.
2. ì‚¬ì „ í›ˆë ¨ëœ ëª¨ë¸ì„ ì¸ìŠ¤í„´ìŠ¤í™”í•©ë‹ˆë‹¤.
3. ğŸ¤— Datasetì„ `tf.data.Dataset`ìœ¼ë¡œ ë³€í™˜í•©ë‹ˆë‹¤.
4. ëª¨ë¸ì„ ì»´íŒŒì¼í•©ë‹ˆë‹¤.
5. ì½œë°±ì„ ì¶”ê°€í•˜ê³  í›ˆë ¨ì„ ìˆ˜í–‰í•˜ê¸° ìœ„í•´ `fit()` ë©”ì†Œë“œë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.
6. ì»¤ë®¤ë‹ˆí‹°ì™€ ê³µìœ í•˜ê¸° ìœ„í•´ ëª¨ë¸ì„ ğŸ¤— Hubì— ì—…ë¡œë“œí•©ë‹ˆë‹¤.

í•˜ì´í¼íŒŒë¼ë¯¸í„°, ì˜µí‹°ë§ˆì´ì € ë° í•™ìŠµë¥  ìŠ¤ì¼€ì¥´ì„ ì •ì˜í•˜ëŠ” ê²ƒìœ¼ë¡œ ì‹œì‘í•©ë‹ˆë‹¤:

```py
>>> from transformers import create_optimizer

>>> batch_size = 16
>>> num_epochs = 5
>>> num_train_steps = len(food["train"]) * num_epochs
>>> learning_rate = 3e-5
>>> weight_decay_rate = 0.01

>>> optimizer, lr_schedule = create_optimizer(
...     init_lr=learning_rate,
...     num_train_steps=num_train_steps,
...     weight_decay_rate=weight_decay_rate,
...     num_warmup_steps=0,
... )
```

ê·¸ëŸ° ë‹¤ìŒ ë ˆì´ë¸” ë§¤í•‘ê³¼ í•¨ê»˜ [`TFAuto ModelForImageClassification`]ìœ¼ë¡œ ViTë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤:

```py
>>> from transformers import TFAutoModelForImageClassification

>>> model = TFAutoModelForImageClassification.from_pretrained(
...     checkpoint,
...     id2label=id2label,
...     label2id=label2id,
... )
```

ë°ì´í„° ì„¸íŠ¸ë¥¼ [`~datasets.Dataset.to_tf_dataset`]ì™€ `data_collator`ë¥¼ ì‚¬ìš©í•˜ì—¬ `tf.data.Dataset` í˜•ì‹ìœ¼ë¡œ ë³€í™˜í•˜ì„¸ìš”:

```py
>>> # converting our train dataset to tf.data.Dataset
>>> tf_train_dataset = food["train"].to_tf_dataset(
...     columns="pixel_values", label_cols="label", shuffle=True, batch_size=batch_size, collate_fn=data_collator
... )

>>> # converting our test dataset to tf.data.Dataset
>>> tf_eval_dataset = food["test"].to_tf_dataset(
...     columns="pixel_values", label_cols="label", shuffle=True, batch_size=batch_size, collate_fn=data_collator
... )
```

`compile()`ë¥¼ ì‚¬ìš©í•˜ì—¬ í›ˆë ¨ ëª¨ë¸ì„ êµ¬ì„±í•˜ì„¸ìš”:

```py
>>> from tensorflow.keras.losses import SparseCategoricalCrossentropy

>>> loss = tf.keras.losses.SparseCategoricalCrossentropy(from_logits=True)
>>> model.compile(optimizer=optimizer, loss=loss)
```

ì˜ˆì¸¡ì—ì„œ ì •í™•ë„ë¥¼ ê³„ì‚°í•˜ê³  ëª¨ë¸ì„ ğŸ¤— Hubë¡œ í‘¸ì‹œí•˜ë ¤ë©´ [Keras callbacks](../main_classes/keras_callbacks)ë¥¼ ì‚¬ìš©í•˜ì„¸ìš”.
`compute_metrics` í•¨ìˆ˜ë¥¼ [KerasMetricCallback](../main_classes/keras_callbacks#transformers.KerasMetricCallback)ì— ì „ë‹¬í•˜ê³ , 
[PushToHubCallback](../main_classes/keras_callbacks#transformers.PushToHubCallback)ì„ ì‚¬ìš©í•˜ì—¬ ëª¨ë¸ì„ ì—…ë¡œë“œí•©ë‹ˆë‹¤:

```py
>>> from transformers.keras_callbacks import KerasMetricCallback, PushToHubCallback

>>> metric_callback = KerasMetricCallback(metric_fn=compute_metrics, eval_dataset=tf_eval_dataset)
>>> push_to_hub_callback = PushToHubCallback(
...     output_dir="food_classifier",
...     tokenizer=image_processor,
...     save_strategy="no",
... )
>>> callbacks = [metric_callback, push_to_hub_callback]
```

ì´ì œ ëª¨ë¸ì„ í›ˆë ¨í•  ì¤€ë¹„ê°€ ë˜ì—ˆìŠµë‹ˆë‹¤! í›ˆë ¨ ë° ê²€ì¦ ë°ì´í„° ì„¸íŠ¸, ì—í­ ìˆ˜ì™€ í•¨ê»˜ `fit()`ì„ í˜¸ì¶œí•˜ê³ ,
ì½œë°±ì„ ì‚¬ìš©í•˜ì—¬ ëª¨ë¸ì„ ë¯¸ì„¸ ì¡°ì •í•©ë‹ˆë‹¤:

```py
>>> model.fit(tf_train_dataset, validation_data=tf_eval_dataset, epochs=num_epochs, callbacks=callbacks)
Epoch 1/5
250/250 [==============================] - 313s 1s/step - loss: 2.5623 - val_loss: 1.4161 - accuracy: 0.9290
Epoch 2/5
250/250 [==============================] - 265s 1s/step - loss: 0.9181 - val_loss: 0.6808 - accuracy: 0.9690
Epoch 3/5
250/250 [==============================] - 252s 1s/step - loss: 0.3910 - val_loss: 0.4303 - accuracy: 0.9820
Epoch 4/5
250/250 [==============================] - 251s 1s/step - loss: 0.2028 - val_loss: 0.3191 - accuracy: 0.9900
Epoch 5/5
250/250 [==============================] - 238s 949ms/step - loss: 0.1232 - val_loss: 0.3259 - accuracy: 0.9890
```

ì¶•í•˜í•©ë‹ˆë‹¤! ëª¨ë¸ì„ ë¯¸ì„¸ ì¡°ì •í•˜ê³  ğŸ¤— Hubì— ê³µìœ í–ˆìŠµë‹ˆë‹¤. ì´ì œ ì¶”ë¡ ì— ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤!
</tf>
</frameworkcontent>


<Tip>

ì´ë¯¸ì§€ ë¶„ë¥˜ë¥¼ ìœ„í•œ ëª¨ë¸ì„ ë¯¸ì„¸ ì¡°ì •í•˜ëŠ” ìì„¸í•œ ì˜ˆì œëŠ” ë‹¤ìŒ [PyTorch notebook](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/image_classification.ipynb)ì„ ì°¸ì¡°í•˜ì„¸ìš”.

</Tip>

## ì¶”ë¡ [[inference]]

ì¢‹ì•„ìš”, ì´ì œ ëª¨ë¸ì„ ë¯¸ì„¸ ì¡°ì •í–ˆìœ¼ë‹ˆ ì¶”ë¡ ì— ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤!

ì¶”ë¡ ì„ ìˆ˜í–‰í•˜ê³ ì í•˜ëŠ” ì´ë¯¸ì§€ë¥¼ ê°€ì ¸ì™€ë´…ì‹œë‹¤:

```py
>>> ds = load_dataset("food101", split="validation[:10]")
>>> image = ds["image"][0]
```

<div class="flex justify-center">
    <img src="https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/beignets-task-guide.png" alt="image of beignets"/>
</div>

ë¯¸ì„¸ ì¡°ì • ëª¨ë¸ë¡œ ì¶”ë¡ ì„ ì‹œë„í•˜ëŠ” ê°€ì¥ ê°„ë‹¨í•œ ë°©ë²•ì€ [`pipeline`]ì„ ì‚¬ìš©í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤. ëª¨ë¸ë¡œ ì´ë¯¸ì§€ ë¶„ë¥˜ë¥¼ ìœ„í•œ `pipeline`ì„ ì¸ìŠ¤í„´ìŠ¤í™”í•˜ê³  ì´ë¯¸ì§€ë¥¼ ì „ë‹¬í•©ë‹ˆë‹¤:

```py
>>> from transformers import pipeline

>>> classifier = pipeline("image-classification", model="my_awesome_food_model")
>>> classifier(image)
[{'score': 0.31856709718704224, 'label': 'beignets'},
 {'score': 0.015232225880026817, 'label': 'bruschetta'},
 {'score': 0.01519392803311348, 'label': 'chicken_wings'},
 {'score': 0.013022331520915031, 'label': 'pork_chop'},
 {'score': 0.012728818692266941, 'label': 'prime_rib'}]
```

ì›í•œë‹¤ë©´, `pipeline`ì˜ ê²°ê³¼ë¥¼ ìˆ˜ë™ìœ¼ë¡œ ë³µì œí•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤:

<frameworkcontent>
<pt>
ì´ë¯¸ì§€ë¥¼ ì „ì²˜ë¦¬í•˜ê¸° ìœ„í•´ ì´ë¯¸ì§€ í”„ë¡œì„¸ì„œë¥¼ ê°€ì ¸ì˜¤ê³  `input`ì„ PyTorch í…ì„œë¡œ ë°˜í™˜í•©ë‹ˆë‹¤:

```py
>>> from transformers import AutoImageProcessor
>>> import torch

>>> image_processor = AutoImageProcessor.from_pretrained("my_awesome_food_model")
>>> inputs = image_processor(image, return_tensors="pt")
```

ì…ë ¥ì„ ëª¨ë¸ì— ì „ë‹¬í•˜ê³  logitsì„ ë°˜í™˜í•©ë‹ˆë‹¤:

```py
>>> from transformers import AutoModelForImageClassification

>>> model = AutoModelForImageClassification.from_pretrained("my_awesome_food_model")
>>> with torch.no_grad():
...     logits = model(**inputs).logits
```

í™•ë¥ ì´ ê°€ì¥ ë†’ì€ ì˜ˆì¸¡ ë ˆì´ë¸”ì„ ê°€ì ¸ì˜¤ê³ , ëª¨ë¸ì˜ `id2label` ë§¤í•‘ì„ ì‚¬ìš©í•˜ì—¬ ë ˆì´ë¸”ë¡œ ë³€í™˜í•©ë‹ˆë‹¤:

```py
>>> predicted_label = logits.argmax(-1).item()
>>> model.config.id2label[predicted_label]
'beignets'
```
</pt>
</frameworkcontent>

<frameworkcontent>
<tf>
ì´ë¯¸ì§€ë¥¼ ì „ì²˜ë¦¬í•˜ê¸° ìœ„í•´ ì´ë¯¸ì§€ í”„ë¡œì„¸ì„œë¥¼ ê°€ì ¸ì˜¤ê³  `input`ì„ TensorFlow í…ì„œë¡œ ë°˜í™˜í•©ë‹ˆë‹¤:

```py
>>> from transformers import AutoImageProcessor

>>> image_processor = AutoImageProcessor.from_pretrained("MariaK/food_classifier")
>>> inputs = image_processor(image, return_tensors="tf")
```

ì…ë ¥ì„ ëª¨ë¸ì— ì „ë‹¬í•˜ê³  logitsì„ ë°˜í™˜í•©ë‹ˆë‹¤:

```py
>>> from transformers import TFAutoModelForImageClassification

>>> model = TFAutoModelForImageClassification.from_pretrained("MariaK/food_classifier")
>>> logits = model(**inputs).logits
```

í™•ë¥ ì´ ê°€ì¥ ë†’ì€ ì˜ˆì¸¡ ë ˆì´ë¸”ì„ ê°€ì ¸ì˜¤ê³ , ëª¨ë¸ì˜ `id2label` ë§¤í•‘ì„ ì‚¬ìš©í•˜ì—¬ ë ˆì´ë¸”ë¡œ ë³€í™˜í•©ë‹ˆë‹¤:

```py
>>> predicted_class_id = int(tf.math.argmax(logits, axis=-1)[0])
>>> model.config.id2label[predicted_class_id]
'beignets'
```

</tf>
</frameworkcontent>
